package toml

// Code generated by peg -switch -inline parse.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleTOML
	ruleExpression
	rulenewline
	rulenewlineW
	rulenewlineU
	rulews
	rulewsnl
	rulecomment
	rulekeyval
	rulekey
	rulebareKey
	rulequotedKey
	ruleval
	ruletable
	rulestdTable
	rulearrayTable
	ruleinlineTable
	ruleinlineTableKeyValues
	ruletableKey
	ruletableKeyComp
	ruletableKeySep
	ruleinlineTableValSep
	ruleinteger
	ruleint
	rulefloat
	rulefrac
	ruleexp
	rulestring
	rulebasicString
	rulebasicChar
	ruleescaped
	rulebasicUnescaped
	ruleescape
	rulemlBasicString
	rulemlBasicBody
	ruleliteralString
	ruleliteralChar
	rulemlLiteralString
	rulemlLiteralBody
	rulemlLiteralChar
	rulehexdigit
	rulehexQuad
	ruleboolean
	ruledateFullYear
	ruledateMonth
	ruledateMDay
	ruletimeHour
	ruletimeMinute
	ruletimeSecond
	ruletimeSecfrac
	ruletimeNumoffset
	ruletimeOffset
	rulepartialTime
	rulefullDate
	rulefullTime
	ruledatetime
	ruledigit
	ruledigitDual
	ruledigitQuad
	rulearray
	rulearrayValues
	rulearraySep
	ruleAction0
	rulePegText
	ruleAction1
	ruleAction2
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
)

var rul3s = [...]string{
	"Unknown",
	"TOML",
	"Expression",
	"newline",
	"newlineW",
	"newlineU",
	"ws",
	"wsnl",
	"comment",
	"keyval",
	"key",
	"bareKey",
	"quotedKey",
	"val",
	"table",
	"stdTable",
	"arrayTable",
	"inlineTable",
	"inlineTableKeyValues",
	"tableKey",
	"tableKeyComp",
	"tableKeySep",
	"inlineTableValSep",
	"integer",
	"int",
	"float",
	"frac",
	"exp",
	"string",
	"basicString",
	"basicChar",
	"escaped",
	"basicUnescaped",
	"escape",
	"mlBasicString",
	"mlBasicBody",
	"literalString",
	"literalChar",
	"mlLiteralString",
	"mlLiteralBody",
	"mlLiteralChar",
	"hexdigit",
	"hexQuad",
	"boolean",
	"dateFullYear",
	"dateMonth",
	"dateMDay",
	"timeHour",
	"timeMinute",
	"timeSecond",
	"timeSecfrac",
	"timeNumoffset",
	"timeOffset",
	"partialTime",
	"fullDate",
	"fullTime",
	"datetime",
	"digit",
	"digitDual",
	"digitQuad",
	"array",
	"arrayValues",
	"arraySep",
	"Action0",
	"PegText",
	"Action1",
	"Action2",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[34m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type tomlParser struct {
	toml

	Buffer string
	buffer []rune
	rules  [91]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *tomlParser) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *tomlParser) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *tomlParser
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *tomlParser) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *tomlParser) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *tomlParser) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			_ = buffer
		case ruleAction1:
			p.SetTableString(begin, end)
		case ruleAction2:
			p.AddLineCount((end - begin) / 2)
		case ruleAction3:
			p.AddLineCount(end - begin)
		case ruleAction4:
			p.AddLineCount(1)
		case ruleAction5:
			p.AddKeyValue()
		case ruleAction6:
			p.SetKey(p.buffer, begin, end)
		case ruleAction7:
			p.SetKey(p.buffer, begin, end)
		case ruleAction8:
			p.SetTime(begin, end)
		case ruleAction9:
			p.SetFloat64(begin, end)
		case ruleAction10:
			p.SetInt64(begin, end)
		case ruleAction11:
			p.SetString(begin, end)
		case ruleAction12:
			p.SetBool(begin, end)
		case ruleAction13:
			p.SetArray(begin, end)
		case ruleAction14:
			p.SetTable(p.buffer, begin, end)
		case ruleAction15:
			p.SetArrayTable(p.buffer, begin, end)
		case ruleAction16:
			p.StartInlineTable()
		case ruleAction17:
			p.EndInlineTable()
		case ruleAction18:
			p.AddTableKey()
		case ruleAction19:
			p.SetBasicString(p.buffer, begin, end)
		case ruleAction20:
			p.SetMultilineString()
		case ruleAction21:
			p.AddMultilineBasicBody(p.buffer, begin, end)
		case ruleAction22:
			p.SetLiteralString(p.buffer, begin, end)
		case ruleAction23:
			p.SetMultilineLiteralString(p.buffer, begin, end)
		case ruleAction24:
			p.StartArray()
		case ruleAction25:
			p.AddArrayVal()
		case ruleAction26:
			p.AddArrayVal()

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*tomlParser) error {
	return func(p *tomlParser) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*tomlParser) error {
	return func(p *tomlParser) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *tomlParser) Init(options ...func(*tomlParser) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 TOML <- <(Expression (newline Expression)* wsnl? !. Action0)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[ruleExpression]() {
					goto l0
				}
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					if !_rules[rulenewline]() {
						goto l3
					}
					if !_rules[ruleExpression]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
				{
					position4, tokenIndex4 := position, tokenIndex
					if !_rules[rulewsnl]() {
						goto l4
					}
					goto l5
				l4:
					position, tokenIndex = position4, tokenIndex4
				}
			l5:
				{
					position6, tokenIndex6 := position, tokenIndex
					if !matchDot() {
						goto l6
					}
					goto l0
				l6:
					position, tokenIndex = position6, tokenIndex6
				}
				{
					add(ruleAction0, position)
				}
				add(ruleTOML, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Expression <- <((<(ws table ws comment? (wsnl keyval ws comment?)*)> Action1) / (ws keyval ws comment?) / (ws comment?) / ws)> */
		func() bool {
			position8, tokenIndex8 := position, tokenIndex
			{
				position9 := position
				{
					position10, tokenIndex10 := position, tokenIndex
					{
						position12 := position
						if !_rules[rulews]() {
							goto l11
						}
						{
							position13 := position
							{
								position14, tokenIndex14 := position, tokenIndex
								{
									position16 := position
									if buffer[position] != rune('[') {
										goto l15
									}
									position++
									if !_rules[rulews]() {
										goto l15
									}
									{
										position17 := position
										if !_rules[ruletableKey]() {
											goto l15
										}
										add(rulePegText, position17)
									}
									if !_rules[rulews]() {
										goto l15
									}
									if buffer[position] != rune(']') {
										goto l15
									}
									position++
									{
										add(ruleAction14, position)
									}
									add(rulestdTable, position16)
								}
								goto l14
							l15:
								position, tokenIndex = position14, tokenIndex14
								{
									position19 := position
									if buffer[position] != rune('[') {
										goto l11
									}
									position++
									if buffer[position] != rune('[') {
										goto l11
									}
									position++
									if !_rules[rulews]() {
										goto l11
									}
									{
										position20 := position
										if !_rules[ruletableKey]() {
											goto l11
										}
										add(rulePegText, position20)
									}
									if !_rules[rulews]() {
										goto l11
									}
									if buffer[position] != rune(']') {
										goto l11
									}
									position++
									if buffer[position] != rune(']') {
										goto l11
									}
									position++
									{
										add(ruleAction15, position)
									}
									add(rulearrayTable, position19)
								}
							}
						l14:
							add(ruletable, position13)
						}
						if !_rules[rulews]() {
							goto l11
						}
						{
							position22, tokenIndex22 := position, tokenIndex
							if !_rules[rulecomment]() {
								goto l22
							}
							goto l23
						l22:
							position, tokenIndex = position22, tokenIndex22
						}
					l23:
					l24:
						{
							position25, tokenIndex25 := position, tokenIndex
							if !_rules[rulewsnl]() {
								goto l25
							}
							if !_rules[rulekeyval]() {
								goto l25
							}
							if !_rules[rulews]() {
								goto l25
							}
							{
								position26, tokenIndex26 := position, tokenIndex
								if !_rules[rulecomment]() {
									goto l26
								}
								goto l27
							l26:
								position, tokenIndex = position26, tokenIndex26
							}
						l27:
							goto l24
						l25:
							position, tokenIndex = position25, tokenIndex25
						}
						add(rulePegText, position12)
					}
					{
						add(ruleAction1, position)
					}
					goto l10
				l11:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l29
					}
					if !_rules[rulekeyval]() {
						goto l29
					}
					if !_rules[rulews]() {
						goto l29
					}
					{
						position30, tokenIndex30 := position, tokenIndex
						if !_rules[rulecomment]() {
							goto l30
						}
						goto l31
					l30:
						position, tokenIndex = position30, tokenIndex30
					}
				l31:
					goto l10
				l29:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l32
					}
					{
						position33, tokenIndex33 := position, tokenIndex
						if !_rules[rulecomment]() {
							goto l33
						}
						goto l34
					l33:
						position, tokenIndex = position33, tokenIndex33
					}
				l34:
					goto l10
				l32:
					position, tokenIndex = position10, tokenIndex10
					if !_rules[rulews]() {
						goto l8
					}
				}
			l10:
				add(ruleExpression, position9)
			}
			return true
		l8:
			position, tokenIndex = position8, tokenIndex8
			return false
		},
		/* 2 newline <- <(newlineW / newlineU)> */
		func() bool {
			position35, tokenIndex35 := position, tokenIndex
			{
				position36 := position
				{
					position37, tokenIndex37 := position, tokenIndex
					{
						position39 := position
						{
							position40 := position
							if buffer[position] != rune('\r') {
								goto l38
							}
							position++
							if buffer[position] != rune('\n') {
								goto l38
							}
							position++
						l41:
							{
								position42, tokenIndex42 := position, tokenIndex
								if buffer[position] != rune('\r') {
									goto l42
								}
								position++
								if buffer[position] != rune('\n') {
									goto l42
								}
								position++
								goto l41
							l42:
								position, tokenIndex = position42, tokenIndex42
							}
							add(rulePegText, position40)
						}
						{
							add(ruleAction2, position)
						}
						add(rulenewlineW, position39)
					}
					goto l37
				l38:
					position, tokenIndex = position37, tokenIndex37
					{
						position44 := position
						{
							position45 := position
							{
								position46, tokenIndex46 := position, tokenIndex
								if buffer[position] != rune('\r') {
									goto l47
								}
								position++
							l48:
								{
									position49, tokenIndex49 := position, tokenIndex
									if buffer[position] != rune('\r') {
										goto l49
									}
									position++
									goto l48
								l49:
									position, tokenIndex = position49, tokenIndex49
								}
								goto l46
							l47:
								position, tokenIndex = position46, tokenIndex46
								if buffer[position] != rune('\n') {
									goto l35
								}
								position++
							l50:
								{
									position51, tokenIndex51 := position, tokenIndex
									if buffer[position] != rune('\n') {
										goto l51
									}
									position++
									goto l50
								l51:
									position, tokenIndex = position51, tokenIndex51
								}
							}
						l46:
							add(rulePegText, position45)
						}
						{
							add(ruleAction3, position)
						}
						add(rulenewlineU, position44)
					}
				}
			l37:
				add(rulenewline, position36)
			}
			return true
		l35:
			position, tokenIndex = position35, tokenIndex35
			return false
		},
		/* 3 newlineW <- <(<('\r' '\n')+> Action2)> */
		nil,
		/* 4 newlineU <- <(<('\r'+ / '\n'+)> Action3)> */
		nil,
		/* 5 ws <- <(' ' / '\t')*> */
		func() bool {
			{
				position56 := position
			l57:
				{
					position58, tokenIndex58 := position, tokenIndex
					{
						position59, tokenIndex59 := position, tokenIndex
						if buffer[position] != rune(' ') {
							goto l60
						}
						position++
						goto l59
					l60:
						position, tokenIndex = position59, tokenIndex59
						if buffer[position] != rune('\t') {
							goto l58
						}
						position++
					}
				l59:
					goto l57
				l58:
					position, tokenIndex = position58, tokenIndex58
				}
				add(rulews, position56)
			}
			return true
		},
		/* 6 wsnl <- <((&('\t') '\t') | (&(' ') ' ') | (&('\n' | '\r') (<('\n' / ('\r' '\n'))> Action4)))*> */
		func() bool {
			{
				position62 := position
			l63:
				{
					position64, tokenIndex64 := position, tokenIndex
					{
						switch buffer[position] {
						case '\t':
							if buffer[position] != rune('\t') {
								goto l64
							}
							position++
						case ' ':
							if buffer[position] != rune(' ') {
								goto l64
							}
							position++
						default:
							{
								position66 := position
								{
									position67, tokenIndex67 := position, tokenIndex
									if buffer[position] != rune('\n') {
										goto l68
									}
									position++
									goto l67
								l68:
									position, tokenIndex = position67, tokenIndex67
									if buffer[position] != rune('\r') {
										goto l64
									}
									position++
									if buffer[position] != rune('\n') {
										goto l64
									}
									position++
								}
							l67:
								add(rulePegText, position66)
							}
							{
								add(ruleAction4, position)
							}
						}
					}

					goto l63
				l64:
					position, tokenIndex = position64, tokenIndex64
				}
				add(rulewsnl, position62)
			}
			return true
		},
		/* 7 comment <- <('#' <('\t' / [ -\U0010ffff])*>)> */
		func() bool {
			position70, tokenIndex70 := position, tokenIndex
			{
				position71 := position
				if buffer[position] != rune('#') {
					goto l70
				}
				position++
				{
					position72 := position
				l73:
					{
						position74, tokenIndex74 := position, tokenIndex
						{
							position75, tokenIndex75 := position, tokenIndex
							if buffer[position] != rune('\t') {
								goto l76
							}
							position++
							goto l75
						l76:
							position, tokenIndex = position75, tokenIndex75
							if c := buffer[position]; c < rune(' ') || c > rune('\U0010ffff') {
								goto l74
							}
							position++
						}
					l75:
						goto l73
					l74:
						position, tokenIndex = position74, tokenIndex74
					}
					add(rulePegText, position72)
				}
				add(rulecomment, position71)
			}
			return true
		l70:
			position, tokenIndex = position70, tokenIndex70
			return false
		},
		/* 8 keyval <- <(key ws '=' ws val Action5)> */
		func() bool {
			position77, tokenIndex77 := position, tokenIndex
			{
				position78 := position
				if !_rules[rulekey]() {
					goto l77
				}
				if !_rules[rulews]() {
					goto l77
				}
				if buffer[position] != rune('=') {
					goto l77
				}
				position++
				if !_rules[rulews]() {
					goto l77
				}
				if !_rules[ruleval]() {
					goto l77
				}
				{
					add(ruleAction5, position)
				}
				add(rulekeyval, position78)
			}
			return true
		l77:
			position, tokenIndex = position77, tokenIndex77
			return false
		},
		/* 9 key <- <(bareKey / quotedKey)> */
		func() bool {
			position80, tokenIndex80 := position, tokenIndex
			{
				position81 := position
				{
					position82, tokenIndex82 := position, tokenIndex
					{
						position84 := position
						{
							position85 := position
							{
								switch buffer[position] {
								case '_':
									if buffer[position] != rune('_') {
										goto l83
									}
									position++
								case '-':
									if buffer[position] != rune('-') {
										goto l83
									}
									position++
								case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z':
									if c := buffer[position]; c < rune('a') || c > rune('z') {
										goto l83
									}
									position++
								case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
									if c := buffer[position]; c < rune('0') || c > rune('9') {
										goto l83
									}
									position++
								default:
									if c := buffer[position]; c < rune('A') || c > rune('Z') {
										goto l83
									}
									position++
								}
							}

						l86:
							{
								position87, tokenIndex87 := position, tokenIndex
								{
									switch buffer[position] {
									case '_':
										if buffer[position] != rune('_') {
											goto l87
										}
										position++
									case '-':
										if buffer[position] != rune('-') {
											goto l87
										}
										position++
									case 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z':
										if c := buffer[position]; c < rune('a') || c > rune('z') {
											goto l87
										}
										position++
									case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
										if c := buffer[position]; c < rune('0') || c > rune('9') {
											goto l87
										}
										position++
									default:
										if c := buffer[position]; c < rune('A') || c > rune('Z') {
											goto l87
										}
										position++
									}
								}

								goto l86
							l87:
								position, tokenIndex = position87, tokenIndex87
							}
							add(rulePegText, position85)
						}
						{
							add(ruleAction6, position)
						}
						add(rulebareKey, position84)
					}
					goto l82
				l83:
					position, tokenIndex = position82, tokenIndex82
					{
						position91 := position
						{
							position92 := position
							if buffer[position] != rune('"') {
								goto l80
							}
							position++
						l93:
							{
								position94, tokenIndex94 := position, tokenIndex
								if !_rules[rulebasicChar]() {
									goto l94
								}
								goto l93
							l94:
								position, tokenIndex = position94, tokenIndex94
							}
							if buffer[position] != rune('"') {
								goto l80
							}
							position++
							add(rulePegText, position92)
						}
						{
							add(ruleAction7, position)
						}
						add(rulequotedKey, position91)
					}
				}
			l82:
				add(rulekey, position81)
			}
			return true
		l80:
			position, tokenIndex = position80, tokenIndex80
			return false
		},
		/* 10 bareKey <- <(<((&('_') '_') | (&('-') '-') | (&('a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z') [a-z]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z') [A-Z]))+> Action6)> */
		nil,
		/* 11 quotedKey <- <(<('"' basicChar* '"')> Action7)> */
		nil,
		/* 12 val <- <((<datetime> Action8) / (<float> Action9) / ((&('{') inlineTable) | (&('[') (<array> Action13)) | (&('f' | 't') (<boolean> Action12)) | (&('"' | '\'') (<string> Action11)) | (&('+' | '-' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') (<integer> Action10))))> */
		func() bool {
			position98, tokenIndex98 := position, tokenIndex
			{
				position99 := position
				{
					position100, tokenIndex100 := position, tokenIndex
					{
						position102 := position
						{
							position103 := position
							{
								position104, tokenIndex104 := position, tokenIndex
								{
									position106 := position
									{
										position107 := position
										{
											position108 := position
											if !_rules[ruledigitDual]() {
												goto l105
											}
											if !_rules[ruledigitDual]() {
												goto l105
											}
											add(ruledigitQuad, position108)
										}
										add(ruledateFullYear, position107)
									}
									if buffer[position] != rune('-') {
										goto l105
									}
									position++
									{
										position109 := position
										if !_rules[ruledigitDual]() {
											goto l105
										}
										add(ruledateMonth, position109)
									}
									if buffer[position] != rune('-') {
										goto l105
									}
									position++
									{
										position110 := position
										if !_rules[ruledigitDual]() {
											goto l105
										}
										add(ruledateMDay, position110)
									}
									add(rulefullDate, position106)
								}
								{
									position111, tokenIndex111 := position, tokenIndex
									if buffer[position] != rune('T') {
										goto l111
									}
									position++
									{
										position113 := position
										if !_rules[rulepartialTime]() {
											goto l111
										}
										{
											position114, tokenIndex114 := position, tokenIndex
											{
												position116 := position
												{
													position117, tokenIndex117 := position, tokenIndex
													if buffer[position] != rune('Z') {
														goto l118
													}
													position++
													goto l117
												l118:
													position, tokenIndex = position117, tokenIndex117
													{
														position119 := position
														{
															position120, tokenIndex120 := position, tokenIndex
															if buffer[position] != rune('-') {
																goto l121
															}
															position++
															goto l120
														l121:
															position, tokenIndex = position120, tokenIndex120
															if buffer[position] != rune('+') {
																goto l114
															}
															position++
														}
													l120:
														if !_rules[ruletimeHour]() {
															goto l114
														}
														if buffer[position] != rune(':') {
															goto l114
														}
														position++
														if !_rules[ruletimeMinute]() {
															goto l114
														}
														add(ruletimeNumoffset, position119)
													}
												}
											l117:
												add(ruletimeOffset, position116)
											}
											goto l115
										l114:
											position, tokenIndex = position114, tokenIndex114
										}
									l115:
										add(rulefullTime, position113)
									}
									goto l112
								l111:
									position, tokenIndex = position111, tokenIndex111
								}
							l112:
								goto l104
							l105:
								position, tokenIndex = position104, tokenIndex104
								if !_rules[rulepartialTime]() {
									goto l101
								}
							}
						l104:
							add(ruledatetime, position103)
						}
						add(rulePegText, position102)
					}
					{
						add(ruleAction8, position)
					}
					goto l100
				l101:
					position, tokenIndex = position100, tokenIndex100
					{
						position124 := position
						{
							position125 := position
							if !_rules[ruleinteger]() {
								goto l123
							}
							{
								position126, tokenIndex126 := position, tokenIndex
								if !_rules[rulefrac]() {
									goto l127
								}
								{
									position128, tokenIndex128 := position, tokenIndex
									if !_rules[ruleexp]() {
										goto l128
									}
									goto l129
								l128:
									position, tokenIndex = position128, tokenIndex128
								}
							l129:
								goto l126
							l127:
								position, tokenIndex = position126, tokenIndex126
								{
									position130, tokenIndex130 := position, tokenIndex
									if !_rules[rulefrac]() {
										goto l130
									}
									goto l131
								l130:
									position, tokenIndex = position130, tokenIndex130
								}
							l131:
								if !_rules[ruleexp]() {
									goto l123
								}
							}
						l126:
							add(rulefloat, position125)
						}
						add(rulePegText, position124)
					}
					{
						add(ruleAction9, position)
					}
					goto l100
				l123:
					position, tokenIndex = position100, tokenIndex100
					{
						switch buffer[position] {
						case '{':
							{
								position134 := position
								if buffer[position] != rune('{') {
									goto l98
								}
								position++
								{
									add(ruleAction16, position)
								}
								if !_rules[rulews]() {
									goto l98
								}
								{
									position136 := position
								l137:
									{
										position138, tokenIndex138 := position, tokenIndex
										if !_rules[rulekeyval]() {
											goto l138
										}
										{
											position139, tokenIndex139 := position, tokenIndex
											{
												position141 := position
												if !_rules[rulews]() {
													goto l139
												}
												if buffer[position] != rune(',') {
													goto l139
												}
												position++
												if !_rules[rulews]() {
													goto l139
												}
												add(ruleinlineTableValSep, position141)
											}
											goto l140
										l139:
											position, tokenIndex = position139, tokenIndex139
										}
									l140:
										goto l137
									l138:
										position, tokenIndex = position138, tokenIndex138
									}
									add(ruleinlineTableKeyValues, position136)
								}
								if !_rules[rulews]() {
									goto l98
								}
								if buffer[position] != rune('}') {
									goto l98
								}
								position++
								{
									add(ruleAction17, position)
								}
								add(ruleinlineTable, position134)
							}
						case '[':
							{
								position143 := position
								{
									position144 := position
									if buffer[position] != rune('[') {
										goto l98
									}
									position++
									{
										add(ruleAction24, position)
									}
									if !_rules[rulewsnl]() {
										goto l98
									}
									{
										position146, tokenIndex146 := position, tokenIndex
										{
											position148 := position
											if !_rules[ruleval]() {
												goto l146
											}
											{
												add(ruleAction25, position)
											}
										l150:
											{
												position151, tokenIndex151 := position, tokenIndex
												if !_rules[rulewsnl]() {
													goto l151
												}
												{
													position152, tokenIndex152 := position, tokenIndex
													if !_rules[rulecomment]() {
														goto l152
													}
													goto l153
												l152:
													position, tokenIndex = position152, tokenIndex152
												}
											l153:
												if !_rules[rulewsnl]() {
													goto l151
												}
												if !_rules[rulearraySep]() {
													goto l151
												}
												if !_rules[rulewsnl]() {
													goto l151
												}
												{
													position154, tokenIndex154 := position, tokenIndex
													if !_rules[rulecomment]() {
														goto l154
													}
													goto l155
												l154:
													position, tokenIndex = position154, tokenIndex154
												}
											l155:
												if !_rules[rulewsnl]() {
													goto l151
												}
												if !_rules[ruleval]() {
													goto l151
												}
												{
													add(ruleAction26, position)
												}
												goto l150
											l151:
												position, tokenIndex = position151, tokenIndex151
											}
											if !_rules[rulewsnl]() {
												goto l146
											}
											{
												position157, tokenIndex157 := position, tokenIndex
												if !_rules[rulearraySep]() {
													goto l157
												}
												goto l158
											l157:
												position, tokenIndex = position157, tokenIndex157
											}
										l158:
											if !_rules[rulewsnl]() {
												goto l146
											}
											{
												position159, tokenIndex159 := position, tokenIndex
												if !_rules[rulecomment]() {
													goto l159
												}
												goto l160
											l159:
												position, tokenIndex = position159, tokenIndex159
											}
										l160:
											add(rulearrayValues, position148)
										}
										goto l147
									l146:
										position, tokenIndex = position146, tokenIndex146
									}
								l147:
									if !_rules[rulewsnl]() {
										goto l98
									}
									if buffer[position] != rune(']') {
										goto l98
									}
									position++
									add(rulearray, position144)
								}
								add(rulePegText, position143)
							}
							{
								add(ruleAction13, position)
							}
						case 'f', 't':
							{
								position162 := position
								{
									position163 := position
									{
										position164, tokenIndex164 := position, tokenIndex
										if buffer[position] != rune('t') {
											goto l165
										}
										position++
										if buffer[position] != rune('r') {
											goto l165
										}
										position++
										if buffer[position] != rune('u') {
											goto l165
										}
										position++
										if buffer[position] != rune('e') {
											goto l165
										}
										position++
										goto l164
									l165:
										position, tokenIndex = position164, tokenIndex164
										if buffer[position] != rune('f') {
											goto l98
										}
										position++
										if buffer[position] != rune('a') {
											goto l98
										}
										position++
										if buffer[position] != rune('l') {
											goto l98
										}
										position++
										if buffer[position] != rune('s') {
											goto l98
										}
										position++
										if buffer[position] != rune('e') {
											goto l98
										}
										position++
									}
								l164:
									add(ruleboolean, position163)
								}
								add(rulePegText, position162)
							}
							{
								add(ruleAction12, position)
							}
						case '"', '\'':
							{
								position167 := position
								{
									position168 := position
									{
										position169, tokenIndex169 := position, tokenIndex
										{
											position171 := position
											if buffer[position] != rune('\'') {
												goto l170
											}
											position++
											if buffer[position] != rune('\'') {
												goto l170
											}
											position++
											if buffer[position] != rune('\'') {
												goto l170
											}
											position++
											{
												position172 := position
												{
													position173 := position
												l174:
													{
														position175, tokenIndex175 := position, tokenIndex
														{
															position176, tokenIndex176 := position, tokenIndex
															if buffer[position] != rune('\'') {
																goto l176
															}
															position++
															if buffer[position] != rune('\'') {
																goto l176
															}
															position++
															if buffer[position] != rune('\'') {
																goto l176
															}
															position++
															goto l175
														l176:
															position, tokenIndex = position176, tokenIndex176
														}
														{
															position177, tokenIndex177 := position, tokenIndex
															{
																position179 := position
																{
																	position180, tokenIndex180 := position, tokenIndex
																	if buffer[position] != rune('\t') {
																		goto l181
																	}
																	position++
																	goto l180
																l181:
																	position, tokenIndex = position180, tokenIndex180
																	if c := buffer[position]; c < rune(' ') || c > rune('\U0010ffff') {
																		goto l178
																	}
																	position++
																}
															l180:
																add(rulemlLiteralChar, position179)
															}
															goto l177
														l178:
															position, tokenIndex = position177, tokenIndex177
															if !_rules[rulenewline]() {
																goto l175
															}
														}
													l177:
														goto l174
													l175:
														position, tokenIndex = position175, tokenIndex175
													}
													add(rulemlLiteralBody, position173)
												}
												add(rulePegText, position172)
											}
											if buffer[position] != rune('\'') {
												goto l170
											}
											position++
											if buffer[position] != rune('\'') {
												goto l170
											}
											position++
											if buffer[position] != rune('\'') {
												goto l170
											}
											position++
											{
												add(ruleAction23, position)
											}
											add(rulemlLiteralString, position171)
										}
										goto l169
									l170:
										position, tokenIndex = position169, tokenIndex169
										{
											position184 := position
											if buffer[position] != rune('\'') {
												goto l183
											}
											position++
											{
												position185 := position
											l186:
												{
													position187, tokenIndex187 := position, tokenIndex
													{
														position188 := position
														{
															switch buffer[position] {
															case '\t':
																if buffer[position] != rune('\t') {
																	goto l187
																}
																position++
															case ' ', '!', '"', '#', '$', '%', '&':
																if c := buffer[position]; c < rune(' ') || c > rune('&') {
																	goto l187
																}
																position++
															default:
																if c := buffer[position]; c < rune('(') || c > rune('\U0010ffff') {
																	goto l187
																}
																position++
															}
														}

														add(ruleliteralChar, position188)
													}
													goto l186
												l187:
													position, tokenIndex = position187, tokenIndex187
												}
												add(rulePegText, position185)
											}
											if buffer[position] != rune('\'') {
												goto l183
											}
											position++
											{
												add(ruleAction22, position)
											}
											add(ruleliteralString, position184)
										}
										goto l169
									l183:
										position, tokenIndex = position169, tokenIndex169
										{
											position192 := position
											if buffer[position] != rune('"') {
												goto l191
											}
											position++
											if buffer[position] != rune('"') {
												goto l191
											}
											position++
											if buffer[position] != rune('"') {
												goto l191
											}
											position++
											{
												position193 := position
											l194:
												{
													position195, tokenIndex195 := position, tokenIndex
													{
														position196, tokenIndex196 := position, tokenIndex
														{
															position198 := position
															{
																position199, tokenIndex199 := position, tokenIndex
																if !_rules[rulebasicChar]() {
																	goto l200
																}
																goto l199
															l200:
																position, tokenIndex = position199, tokenIndex199
																if !_rules[rulenewline]() {
																	goto l197
																}
															}
														l199:
															add(rulePegText, position198)
														}
														{
															add(ruleAction21, position)
														}
														goto l196
													l197:
														position, tokenIndex = position196, tokenIndex196
														if !_rules[ruleescape]() {
															goto l195
														}
														if !_rules[rulenewline]() {
															goto l195
														}
														if !_rules[rulewsnl]() {
															goto l195
														}
													}
												l196:
													goto l194
												l195:
													position, tokenIndex = position195, tokenIndex195
												}
												add(rulemlBasicBody, position193)
											}
											if buffer[position] != rune('"') {
												goto l191
											}
											position++
											if buffer[position] != rune('"') {
												goto l191
											}
											position++
											if buffer[position] != rune('"') {
												goto l191
											}
											position++
											{
												add(ruleAction20, position)
											}
											add(rulemlBasicString, position192)
										}
										goto l169
									l191:
										position, tokenIndex = position169, tokenIndex169
										{
											position203 := position
											{
												position204 := position
												if buffer[position] != rune('"') {
													goto l98
												}
												position++
											l205:
												{
													position206, tokenIndex206 := position, tokenIndex
													if !_rules[rulebasicChar]() {
														goto l206
													}
													goto l205
												l206:
													position, tokenIndex = position206, tokenIndex206
												}
												if buffer[position] != rune('"') {
													goto l98
												}
												position++
												add(rulePegText, position204)
											}
											{
												add(ruleAction19, position)
											}
											add(rulebasicString, position203)
										}
									}
								l169:
									add(rulestring, position168)
								}
								add(rulePegText, position167)
							}
							{
								add(ruleAction11, position)
							}
						default:
							{
								position209 := position
								if !_rules[ruleinteger]() {
									goto l98
								}
								add(rulePegText, position209)
							}
							{
								add(ruleAction10, position)
							}
						}
					}

				}
			l100:
				add(ruleval, position99)
			}
			return true
		l98:
			position, tokenIndex = position98, tokenIndex98
			return false
		},
		/* 13 table <- <(stdTable / arrayTable)> */
		nil,
		/* 14 stdTable <- <('[' ws <tableKey> ws ']' Action14)> */
		nil,
		/* 15 arrayTable <- <('[' '[' ws <tableKey> ws (']' ']') Action15)> */
		nil,
		/* 16 inlineTable <- <('{' Action16 ws inlineTableKeyValues ws '}' Action17)> */
		nil,
		/* 17 inlineTableKeyValues <- <(keyval inlineTableValSep?)*> */
		nil,
		/* 18 tableKey <- <(tableKeyComp (tableKeySep tableKeyComp)*)> */
		func() bool {
			position216, tokenIndex216 := position, tokenIndex
			{
				position217 := position
				if !_rules[ruletableKeyComp]() {
					goto l216
				}
			l218:
				{
					position219, tokenIndex219 := position, tokenIndex
					{
						position220 := position
						if !_rules[rulews]() {
							goto l219
						}
						if buffer[position] != rune('.') {
							goto l219
						}
						position++
						if !_rules[rulews]() {
							goto l219
						}
						add(ruletableKeySep, position220)
					}
					if !_rules[ruletableKeyComp]() {
						goto l219
					}
					goto l218
				l219:
					position, tokenIndex = position219, tokenIndex219
				}
				add(ruletableKey, position217)
			}
			return true
		l216:
			position, tokenIndex = position216, tokenIndex216
			return false
		},
		/* 19 tableKeyComp <- <(key Action18)> */
		func() bool {
			position221, tokenIndex221 := position, tokenIndex
			{
				position222 := position
				if !_rules[rulekey]() {
					goto l221
				}
				{
					add(ruleAction18, position)
				}
				add(ruletableKeyComp, position222)
			}
			return true
		l221:
			position, tokenIndex = position221, tokenIndex221
			return false
		},
		/* 20 tableKeySep <- <(ws '.' ws)> */
		nil,
		/* 21 inlineTableValSep <- <(ws ',' ws)> */
		nil,
		/* 22 integer <- <(('-' / '+')? int)> */
		func() bool {
			position226, tokenIndex226 := position, tokenIndex
			{
				position227 := position
				{
					position228, tokenIndex228 := position, tokenIndex
					{
						position230, tokenIndex230 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l231
						}
						position++
						goto l230
					l231:
						position, tokenIndex = position230, tokenIndex230
						if buffer[position] != rune('+') {
							goto l228
						}
						position++
					}
				l230:
					goto l229
				l228:
					position, tokenIndex = position228, tokenIndex228
				}
			l229:
				{
					position232 := position
					{
						position233, tokenIndex233 := position, tokenIndex
						if c := buffer[position]; c < rune('1') || c > rune('9') {
							goto l234
						}
						position++
						{
							position237, tokenIndex237 := position, tokenIndex
							if !_rules[ruledigit]() {
								goto l238
							}
							goto l237
						l238:
							position, tokenIndex = position237, tokenIndex237
							if buffer[position] != rune('_') {
								goto l234
							}
							position++
							if !_rules[ruledigit]() {
								goto l234
							}
						}
					l237:
					l235:
						{
							position236, tokenIndex236 := position, tokenIndex
							{
								position239, tokenIndex239 := position, tokenIndex
								if !_rules[ruledigit]() {
									goto l240
								}
								goto l239
							l240:
								position, tokenIndex = position239, tokenIndex239
								if buffer[position] != rune('_') {
									goto l236
								}
								position++
								if !_rules[ruledigit]() {
									goto l236
								}
							}
						l239:
							goto l235
						l236:
							position, tokenIndex = position236, tokenIndex236
						}
						goto l233
					l234:
						position, tokenIndex = position233, tokenIndex233
						if !_rules[ruledigit]() {
							goto l226
						}
					}
				l233:
					add(ruleint, position232)
				}
				add(ruleinteger, position227)
			}
			return true
		l226:
			position, tokenIndex = position226, tokenIndex226
			return false
		},
		/* 23 int <- <(([1-9] (digit / ('_' digit))+) / digit)> */
		nil,
		/* 24 float <- <(integer ((frac exp?) / (frac? exp)))> */
		nil,
		/* 25 frac <- <('.' digit (digit / ('_' digit))*)> */
		func() bool {
			position243, tokenIndex243 := position, tokenIndex
			{
				position244 := position
				if buffer[position] != rune('.') {
					goto l243
				}
				position++
				if !_rules[ruledigit]() {
					goto l243
				}
			l245:
				{
					position246, tokenIndex246 := position, tokenIndex
					{
						position247, tokenIndex247 := position, tokenIndex
						if !_rules[ruledigit]() {
							goto l248
						}
						goto l247
					l248:
						position, tokenIndex = position247, tokenIndex247
						if buffer[position] != rune('_') {
							goto l246
						}
						position++
						if !_rules[ruledigit]() {
							goto l246
						}
					}
				l247:
					goto l245
				l246:
					position, tokenIndex = position246, tokenIndex246
				}
				add(rulefrac, position244)
			}
			return true
		l243:
			position, tokenIndex = position243, tokenIndex243
			return false
		},
		/* 26 exp <- <(('e' / 'E') ('-' / '+')? digit (digit / ('_' digit))*)> */
		func() bool {
			position249, tokenIndex249 := position, tokenIndex
			{
				position250 := position
				{
					position251, tokenIndex251 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l252
					}
					position++
					goto l251
				l252:
					position, tokenIndex = position251, tokenIndex251
					if buffer[position] != rune('E') {
						goto l249
					}
					position++
				}
			l251:
				{
					position253, tokenIndex253 := position, tokenIndex
					{
						position255, tokenIndex255 := position, tokenIndex
						if buffer[position] != rune('-') {
							goto l256
						}
						position++
						goto l255
					l256:
						position, tokenIndex = position255, tokenIndex255
						if buffer[position] != rune('+') {
							goto l253
						}
						position++
					}
				l255:
					goto l254
				l253:
					position, tokenIndex = position253, tokenIndex253
				}
			l254:
				if !_rules[ruledigit]() {
					goto l249
				}
			l257:
				{
					position258, tokenIndex258 := position, tokenIndex
					{
						position259, tokenIndex259 := position, tokenIndex
						if !_rules[ruledigit]() {
							goto l260
						}
						goto l259
					l260:
						position, tokenIndex = position259, tokenIndex259
						if buffer[position] != rune('_') {
							goto l258
						}
						position++
						if !_rules[ruledigit]() {
							goto l258
						}
					}
				l259:
					goto l257
				l258:
					position, tokenIndex = position258, tokenIndex258
				}
				add(ruleexp, position250)
			}
			return true
		l249:
			position, tokenIndex = position249, tokenIndex249
			return false
		},
		/* 27 string <- <(mlLiteralString / literalString / mlBasicString / basicString)> */
		nil,
		/* 28 basicString <- <(<('"' basicChar* '"')> Action19)> */
		nil,
		/* 29 basicChar <- <(basicUnescaped / escaped)> */
		func() bool {
			position263, tokenIndex263 := position, tokenIndex
			{
				position264 := position
				{
					position265, tokenIndex265 := position, tokenIndex
					{
						position267 := position
						{
							switch buffer[position] {
							case ' ', '!':
								if c := buffer[position]; c < rune(' ') || c > rune('!') {
									goto l266
								}
								position++
							case '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?', '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[':
								if c := buffer[position]; c < rune('#') || c > rune('[') {
									goto l266
								}
								position++
							default:
								if c := buffer[position]; c < rune(']') || c > rune('\U0010ffff') {
									goto l266
								}
								position++
							}
						}

						add(rulebasicUnescaped, position267)
					}
					goto l265
				l266:
					position, tokenIndex = position265, tokenIndex265
					{
						position269 := position
						if !_rules[ruleescape]() {
							goto l263
						}
						{
							switch buffer[position] {
							case 'U':
								if buffer[position] != rune('U') {
									goto l263
								}
								position++
								if !_rules[rulehexQuad]() {
									goto l263
								}
								if !_rules[rulehexQuad]() {
									goto l263
								}
							case 'u':
								if buffer[position] != rune('u') {
									goto l263
								}
								position++
								if !_rules[rulehexQuad]() {
									goto l263
								}
							case '\\':
								if buffer[position] != rune('\\') {
									goto l263
								}
								position++
							case '/':
								if buffer[position] != rune('/') {
									goto l263
								}
								position++
							case '"':
								if buffer[position] != rune('"') {
									goto l263
								}
								position++
							case 'r':
								if buffer[position] != rune('r') {
									goto l263
								}
								position++
							case 'f':
								if buffer[position] != rune('f') {
									goto l263
								}
								position++
							case 'n':
								if buffer[position] != rune('n') {
									goto l263
								}
								position++
							case 't':
								if buffer[position] != rune('t') {
									goto l263
								}
								position++
							default:
								if buffer[position] != rune('b') {
									goto l263
								}
								position++
							}
						}

						add(ruleescaped, position269)
					}
				}
			l265:
				add(rulebasicChar, position264)
			}
			return true
		l263:
			position, tokenIndex = position263, tokenIndex263
			return false
		},
		/* 30 escaped <- <(escape ((&('U') ('U' hexQuad hexQuad)) | (&('u') ('u' hexQuad)) | (&('\\') '\\') | (&('/') '/') | (&('"') '"') | (&('r') 'r') | (&('f') 'f') | (&('n') 'n') | (&('t') 't') | (&('b') 'b')))> */
		nil,
		/* 31 basicUnescaped <- <((&(' ' | '!') [ -!]) | (&('#' | '$' | '%' | '&' | '\'' | '(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '[') [#-[]) | (&(']' | '^' | '_' | '`' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | '{' | '|' | '}' | '~' | '\u007f' | '\u0080' | '\u0081' | '\u0082' | '\u0083' | '\u0084' | '\u0085' | '\u0086' | '\u0087' | '\u0088' | '\u0089' | '\u008a' | '\u008b' | '\u008c' | '\u008d' | '\u008e' | '\u008f' | '\u0090' | '\u0091' | '\u0092' | '\u0093' | '\u0094' | '\u0095' | '\u0096' | '\u0097' | '\u0098' | '\u0099' | '\u009a' | '\u009b' | '\u009c' | '\u009d' | '\u009e' | '\u009f' | '\u00a0' | '¡' | '¢' | '£' | '¤' | '¥' | '¦' | '§' | '¨' | '©' | 'ª' | '«' | '¬' | '\u00ad' | '®' | '¯' | '°' | '±' | '²' | '³' | '´' | 'µ' | '¶' | '·' | '¸' | '¹' | 'º' | '»' | '¼' | '½' | '¾' | '¿' | 'À' | 'Á' | 'Â' | 'Ã' | 'Ä' | 'Å' | 'Æ' | 'Ç' | 'È' | 'É' | 'Ê' | 'Ë' | 'Ì' | 'Í' | 'Î' | 'Ï' | 'Ð' | 'Ñ' | 'Ò' | 'Ó' | 'Ô' | 'Õ' | 'Ö' | '×' | 'Ø' | 'Ù' | 'Ú' | 'Û' | 'Ü' | 'Ý' | 'Þ' | 'ß' | 'à' | 'á' | 'â' | 'ã' | 'ä' | 'å' | 'æ' | 'ç' | 'è' | 'é' | 'ê' | 'ë' | 'ì' | 'í' | 'î' | 'ï' | 'ð' | 'ñ' | 'ò' | 'ó' | 'ô' | 'õ' | 'ö' | '÷' | 'ø' | 'ù' | 'ú' | 'û' | 'ü' | 'ý' | 'þ' | 'ÿ') []-\U0010ffff]))> */
		nil,
		/* 32 escape <- <'\\'> */
		func() bool {
			position273, tokenIndex273 := position, tokenIndex
			{
				position274 := position
				if buffer[position] != rune('\\') {
					goto l273
				}
				position++
				add(ruleescape, position274)
			}
			return true
		l273:
			position, tokenIndex = position273, tokenIndex273
			return false
		},
		/* 33 mlBasicString <- <('"' '"' '"' mlBasicBody ('"' '"' '"') Action20)> */
		nil,
		/* 34 mlBasicBody <- <((<(basicChar / newline)> Action21) / (escape newline wsnl))*> */
		nil,
		/* 35 literalString <- <('\'' <literalChar*> '\'' Action22)> */
		nil,
		/* 36 literalChar <- <((&('\t') '\t') | (&(' ' | '!' | '"' | '#' | '$' | '%' | '&') [ -&]) | (&('(' | ')' | '*' | '+' | ',' | '-' | '.' | '/' | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':' | ';' | '<' | '=' | '>' | '?' | '@' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R' | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' | '[' | '\\' | ']' | '^' | '_' | '`' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r' | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' | '{' | '|' | '}' | '~' | '\u007f' | '\u0080' | '\u0081' | '\u0082' | '\u0083' | '\u0084' | '\u0085' | '\u0086' | '\u0087' | '\u0088' | '\u0089' | '\u008a' | '\u008b' | '\u008c' | '\u008d' | '\u008e' | '\u008f' | '\u0090' | '\u0091' | '\u0092' | '\u0093' | '\u0094' | '\u0095' | '\u0096' | '\u0097' | '\u0098' | '\u0099' | '\u009a' | '\u009b' | '\u009c' | '\u009d' | '\u009e' | '\u009f' | '\u00a0' | '¡' | '¢' | '£' | '¤' | '¥' | '¦' | '§' | '¨' | '©' | 'ª' | '«' | '¬' | '\u00ad' | '®' | '¯' | '°' | '±' | '²' | '³' | '´' | 'µ' | '¶' | '·' | '¸' | '¹' | 'º' | '»' | '¼' | '½' | '¾' | '¿' | 'À' | 'Á' | 'Â' | 'Ã' | 'Ä' | 'Å' | 'Æ' | 'Ç' | 'È' | 'É' | 'Ê' | 'Ë' | 'Ì' | 'Í' | 'Î' | 'Ï' | 'Ð' | 'Ñ' | 'Ò' | 'Ó' | 'Ô' | 'Õ' | 'Ö' | '×' | 'Ø' | 'Ù' | 'Ú' | 'Û' | 'Ü' | 'Ý' | 'Þ' | 'ß' | 'à' | 'á' | 'â' | 'ã' | 'ä' | 'å' | 'æ' | 'ç' | 'è' | 'é' | 'ê' | 'ë' | 'ì' | 'í' | 'î' | 'ï' | 'ð' | 'ñ' | 'ò' | 'ó' | 'ô' | 'õ' | 'ö' | '÷' | 'ø' | 'ù' | 'ú' | 'û' | 'ü' | 'ý' | 'þ' | 'ÿ') [(-\U0010ffff]))> */
		nil,
		/* 37 mlLiteralString <- <('\'' '\'' '\'' <mlLiteralBody> ('\'' '\'' '\'') Action23)> */
		nil,
		/* 38 mlLiteralBody <- <(!('\'' '\'' '\'') (mlLiteralChar / newline))*> */
		nil,
		/* 39 mlLiteralChar <- <('\t' / [ -\U0010ffff])> */
		nil,
		/* 40 hexdigit <- <((&('a' | 'b' | 'c' | 'd' | 'e' | 'f') [a-f]) | (&('A' | 'B' | 'C' | 'D' | 'E' | 'F') [A-F]) | (&('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9') [0-9]))> */
		func() bool {
			position282, tokenIndex282 := position, tokenIndex
			{
				position283 := position
				{
					switch buffer[position] {
					case 'a', 'b', 'c', 'd', 'e', 'f':
						if c := buffer[position]; c < rune('a') || c > rune('f') {
							goto l282
						}
						position++
					case 'A', 'B', 'C', 'D', 'E', 'F':
						if c := buffer[position]; c < rune('A') || c > rune('F') {
							goto l282
						}
						position++
					default:
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l282
						}
						position++
					}
				}

				add(rulehexdigit, position283)
			}
			return true
		l282:
			position, tokenIndex = position282, tokenIndex282
			return false
		},
		/* 41 hexQuad <- <(hexdigit hexdigit hexdigit hexdigit)> */
		func() bool {
			position285, tokenIndex285 := position, tokenIndex
			{
				position286 := position
				if !_rules[rulehexdigit]() {
					goto l285
				}
				if !_rules[rulehexdigit]() {
					goto l285
				}
				if !_rules[rulehexdigit]() {
					goto l285
				}
				if !_rules[rulehexdigit]() {
					goto l285
				}
				add(rulehexQuad, position286)
			}
			return true
		l285:
			position, tokenIndex = position285, tokenIndex285
			return false
		},
		/* 42 boolean <- <(('t' 'r' 'u' 'e') / ('f' 'a' 'l' 's' 'e'))> */
		nil,
		/* 43 dateFullYear <- <digitQuad> */
		nil,
		/* 44 dateMonth <- <digitDual> */
		nil,
		/* 45 dateMDay <- <digitDual> */
		nil,
		/* 46 timeHour <- <digitDual> */
		func() bool {
			position291, tokenIndex291 := position, tokenIndex
			{
				position292 := position
				if !_rules[ruledigitDual]() {
					goto l291
				}
				add(ruletimeHour, position292)
			}
			return true
		l291:
			position, tokenIndex = position291, tokenIndex291
			return false
		},
		/* 47 timeMinute <- <digitDual> */
		func() bool {
			position293, tokenIndex293 := position, tokenIndex
			{
				position294 := position
				if !_rules[ruledigitDual]() {
					goto l293
				}
				add(ruletimeMinute, position294)
			}
			return true
		l293:
			position, tokenIndex = position293, tokenIndex293
			return false
		},
		/* 48 timeSecond <- <digitDual> */
		nil,
		/* 49 timeSecfrac <- <('.' digit+)> */
		nil,
		/* 50 timeNumoffset <- <(('-' / '+') timeHour ':' timeMinute)> */
		nil,
		/* 51 timeOffset <- <('Z' / timeNumoffset)> */
		nil,
		/* 52 partialTime <- <(timeHour ':' timeMinute ':' timeSecond timeSecfrac?)> */
		func() bool {
			position299, tokenIndex299 := position, tokenIndex
			{
				position300 := position
				if !_rules[ruletimeHour]() {
					goto l299
				}
				if buffer[position] != rune(':') {
					goto l299
				}
				position++
				if !_rules[ruletimeMinute]() {
					goto l299
				}
				if buffer[position] != rune(':') {
					goto l299
				}
				position++
				{
					position301 := position
					if !_rules[ruledigitDual]() {
						goto l299
					}
					add(ruletimeSecond, position301)
				}
				{
					position302, tokenIndex302 := position, tokenIndex
					{
						position304 := position
						if buffer[position] != rune('.') {
							goto l302
						}
						position++
						if !_rules[ruledigit]() {
							goto l302
						}
					l305:
						{
							position306, tokenIndex306 := position, tokenIndex
							if !_rules[ruledigit]() {
								goto l306
							}
							goto l305
						l306:
							position, tokenIndex = position306, tokenIndex306
						}
						add(ruletimeSecfrac, position304)
					}
					goto l303
				l302:
					position, tokenIndex = position302, tokenIndex302
				}
			l303:
				add(rulepartialTime, position300)
			}
			return true
		l299:
			position, tokenIndex = position299, tokenIndex299
			return false
		},
		/* 53 fullDate <- <(dateFullYear '-' dateMonth '-' dateMDay)> */
		nil,
		/* 54 fullTime <- <(partialTime timeOffset?)> */
		nil,
		/* 55 datetime <- <((fullDate ('T' fullTime)?) / partialTime)> */
		nil,
		/* 56 digit <- <[0-9]> */
		func() bool {
			position310, tokenIndex310 := position, tokenIndex
			{
				position311 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l310
				}
				position++
				add(ruledigit, position311)
			}
			return true
		l310:
			position, tokenIndex = position310, tokenIndex310
			return false
		},
		/* 57 digitDual <- <(digit digit)> */
		func() bool {
			position312, tokenIndex312 := position, tokenIndex
			{
				position313 := position
				if !_rules[ruledigit]() {
					goto l312
				}
				if !_rules[ruledigit]() {
					goto l312
				}
				add(ruledigitDual, position313)
			}
			return true
		l312:
			position, tokenIndex = position312, tokenIndex312
			return false
		},
		/* 58 digitQuad <- <(digitDual digitDual)> */
		nil,
		/* 59 array <- <('[' Action24 wsnl arrayValues? wsnl ']')> */
		nil,
		/* 60 arrayValues <- <(val Action25 (wsnl comment? wsnl arraySep wsnl comment? wsnl val Action26)* wsnl arraySep? wsnl comment?)> */
		nil,
		/* 61 arraySep <- <','> */
		func() bool {
			position317, tokenIndex317 := position, tokenIndex
			{
				position318 := position
				if buffer[position] != rune(',') {
					goto l317
				}
				position++
				add(rulearraySep, position318)
			}
			return true
		l317:
			position, tokenIndex = position317, tokenIndex317
			return false
		},
		/* 63 Action0 <- <{ _ = buffer }> */
		nil,
		nil,
		/* 65 Action1 <- <{ p.SetTableString(begin, end) }> */
		nil,
		/* 66 Action2 <- <{ p.AddLineCount((end - begin)/2) }> */
		nil,
		/* 67 Action3 <- <{ p.AddLineCount(end - begin) }> */
		nil,
		/* 68 Action4 <- <{ p.AddLineCount(1) }> */
		nil,
		/* 69 Action5 <- <{ p.AddKeyValue() }> */
		nil,
		/* 70 Action6 <- <{ p.SetKey(p.buffer, begin, end) }> */
		nil,
		/* 71 Action7 <- <{ p.SetKey(p.buffer, begin, end) }> */
		nil,
		/* 72 Action8 <- <{ p.SetTime(begin, end) }> */
		nil,
		/* 73 Action9 <- <{ p.SetFloat64(begin, end) }> */
		nil,
		/* 74 Action10 <- <{ p.SetInt64(begin, end) }> */
		nil,
		/* 75 Action11 <- <{ p.SetString(begin, end) }> */
		nil,
		/* 76 Action12 <- <{ p.SetBool(begin, end) }> */
		nil,
		/* 77 Action13 <- <{ p.SetArray(begin, end) }> */
		nil,
		/* 78 Action14 <- <{ p.SetTable(p.buffer, begin, end) }> */
		nil,
		/* 79 Action15 <- <{ p.SetArrayTable(p.buffer, begin, end) }> */
		nil,
		/* 80 Action16 <- <{ p.StartInlineTable() }> */
		nil,
		/* 81 Action17 <- <{ p.EndInlineTable() }> */
		nil,
		/* 82 Action18 <- <{ p.AddTableKey() }> */
		nil,
		/* 83 Action19 <- <{ p.SetBasicString(p.buffer, begin, end) }> */
		nil,
		/* 84 Action20 <- <{ p.SetMultilineString() }> */
		nil,
		/* 85 Action21 <- <{ p.AddMultilineBasicBody(p.buffer, begin, end) }> */
		nil,
		/* 86 Action22 <- <{ p.SetLiteralString(p.buffer, begin, end) }> */
		nil,
		/* 87 Action23 <- <{ p.SetMultilineLiteralString(p.buffer, begin, end) }> */
		nil,
		/* 88 Action24 <- <{ p.StartArray() }> */
		nil,
		/* 89 Action25 <- <{ p.AddArrayVal() }> */
		nil,
		/* 90 Action26 <- <{ p.AddArrayVal() }> */
		nil,
	}
	p.rules = _rules
	return nil
}
